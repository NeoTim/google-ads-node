const fs = require("fs");
const { GoogleAdsClient } = require("../build/index");
const {
  SearchGoogleAdsFieldsRequest,
  SearchGoogleAdsFieldsResponse,
  GoogleAdsFieldCategoryEnum,
} = require("../build/lib/types");

/* 
  This file is used for generating "fields.ts".
  It should only be run when updating the Google Ads API version
*/

const CLIENT_ID = process.env.GADS_CLIENT_ID;
const CLIENT_SECRET = process.env.GADS_CLIENT_SECRET;
const REFRESH_TOKEN = process.env.GADS_REFRESH_TOKEN;
const DEVELOPER_TOKEN = process.env.GADS_DEVELOPER_TOKEN;

const client = new GoogleAdsClient({
  client_id: CLIENT_ID,
  client_secret: CLIENT_SECRET,
  refresh_token: REFRESH_TOKEN,
  developer_token: DEVELOPER_TOKEN,
  parseResults: true,
});
const service = client.getService("GoogleAdsFieldService");
const stream = fs.createWriteStream(__dirname + "/../src/lib/fields.ts");

async function main() {
  const { resultsList } = await getAllFields();
  const resources = {};
  const segments = [];
  const metrics = [];

  for (const row of resultsList) {
    if (isResource(row.category)) {
      resources[row.name] = [];
    }
    if (isAttribute(row.category)) {
      const resourceName = row.name.split(".")[0];
      resources[resourceName].push(row);
    }
    if (isSegment(row.category)) {
      segments.push(row);
    }
    if (isMetric(row.category)) {
      metrics.push(row);
    }
  }

  stream.write(`/* Autogenerated File! Do Not Edit */\n`);

  /* RESOURCES */
  stream.write(`\n/*\n  -- RESOURCES --\n*/`);
  for (const resource in resources) {
    const fields = resources[resource];
    if (!fields) continue;

    stream.write(`\nexport const ${resource} = [\n`);
    for (const field of fields) {
      stream.write(`"${field.name}",\n`);
    }
    stream.write(`]\n\n`);

    buildUnionArray(fields, `${resource}_field`, `${resource}.`);
  }

  /* SEGMENTS */
  stream.write(`\n/*\n  -- SEGMENTS --\n*/`);
  buildUnionArray(segments, "Segment", "segments.");

  /* METRICS */
  stream.write(`\n/*\n  -- METRICS --\n*/`);
  buildUnionArray(metrics, "Metric", "metrics.");

  stream.end();
}

function buildUnionArray(fields, unionName, delimeter) {
  stream.write(`\nexport type ${unionName} = \n`);
  for (const field of fields) {
    stream.write(`"${field.name.replace(delimeter, "")}"`);
    if (fields.indexOf(field) !== fields.length - 1) {
      stream.write(`| \n`);
    }
  }
  stream.write(`\n\nexport type ${unionName}s = Array<${unionName}>\n`);
}

function isResource(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.RESOURCE;
}

function isAttribute(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.ATTRIBUTE;
}

function isSegment(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.SEGMENT;
}

function isMetric(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.METRIC;
}

async function getAllFields() {
  const request = new SearchGoogleAdsFieldsRequest();
  request.setQuery(`
    SELECT 
      name,
      category,
      selectable,
      filterable
  `);
  /* Other possible fields */
  // selectable_with,
  // attribute_resources,
  // metrics,
  // segments

  const response = await service.searchGoogleAdsFields(request);
  return response;
}

main();
